# Step01

## ReactiveX 기초

### ReactiveX 정의
- 효율적이고 직관적인 비동기 프로그래밍을 지원하기 위해 개발된 라이브러리
- Observer pattern 사용  
  
  > ### Reactive 어원 및 wiki keyword
  > - 반응을 보이는, 반응하는
  >   > - 관찰 가능한 흐름과 함께 비동기 프로그래밍을 위한 api  
  >   > - 옵저버 pattern 과 이터레이터 pattern, 그리고 함수형 프로그래밍을 이용한 반응형 프로그램
  > 
  > - ~한다면, ~라면
  >   > - (버튼을 클릭) 한다면 / (로그인이 완료된 상태) 라면 / (데이터가 변경된 상태) 라면  
  >   > - 위의 조건문을 구독하는 개념
  >   > - 위의 조건 발생 시, 그 조건에 매치된 명령문들이 실행됨

### 왜 비동기 프로그래밍?
- 적어도 아래 고민을 해본 적이 있다면 그 고민에 대한 해결책은 비동기이다.
  > 1. 사용자 경험을 향상시키고 싶다. 
  > 2. 반응형 앱을 만들고 싶다. 
  > 3. 메인스레드가 멈추거나 느려지지 않도록 하여, 사용자들에게 부드러운 사용자 경험과 좋은 성능을 제공하고 싶다.

### 모든 비동기작업을 처리하는 라이브러리에서 필요한 것 (평가 매트릭스)
![image](https://github.com/ridickle7/Java_ReactiveX/blob/master/src/main/java/_step01/res/evaluation_matrix.png?raw=true)
- 명시적 실행 (Explicit execution)
  > 새로운 스레드에서 작업을 시작하면, 그것을 **컨트롤할 수 있어야 한다.**  
  > 백그라운드 작업을 수행하려면, 정보를 모으고 준비해야 한다.  
  > 준비가 되면 바로 백그라운드 작업을 시작할 수 있다.

- 쉬운 스레드 관리(Easy thread management)
  > 비동기작업에서는 스레드 관리가 핵심이다.  
  > 백그라운드 작업 도중이나 작업이 끝난 후, 메인스레드에서 UI를 업데이트해야 할 때가 있다.  
  > 우리의 작업을 하나의 스레드(백그라운드 스레드)에서 다른 스레드(메인 스레드)로 넘겨야한다.  
  > 그래서 **스레드를 쉽게 전환**하고, 필요한 경우 **다른 스레드로 작업을 넘길 수 있어야 한다**.
  
- 쉬운 구성력(Easily composable)
  > 이상적으로, 비동기작업을 생성하고 백그라운드 작업으로 시작하면, 그것은 다른 어떤 스레드(특히 UI 스레드)에 의존하지 않고 작업이 끝날때까지 다른 스레드와는 독립적으로 유지하는 것이 좋다.   
  > 하지만 **실제로는**, UI를 업데이트하고 데이터베이스를 변경하는 등 **많은 것들을 스레드 상호 의존적**으로 만들어야 한다.  
  > 그래서 비동기 라이브러리는 **쉽게 구성**할 수 있어야 하고 **오류가 발생할 여지가 적어야 한다**.

- 부작용 최소화(Minimum the side effects)
  > 멀티 스레드가 수행되는 동안, **스레드 서로간 영향을 끼치는 부작용을 최소화**해야한다.   
  > 그것은 새로운 사람이 당신의 코드를 쉽게 읽고 이해할 수 있게 해주고, 오류를 쉽게 추적할 수 있게 한다.

### Hello ReactiveX
<pre><code>// 기존 프로그래밍 방식
System.out.println("doc1");
System.out.println("doc2");
System.out.println("doc3");
</code></pre>

<pre><code>// RxJava를 활용한 프로그래밍 방식
Observable.just("doc1", "doc2", "doc3").subscribe(System.out::println);
</code></pre>


### ref
- [대한민국 개발자 아빠 블로그](https://dev-daddy.tistory.com/25)
- [마기의 개발 블로그](https://magi82.github.io/ios-rxswift-01/)
